<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functions</title>
    <link rel="stylesheet" href="../style.css">
    <script src="functions.js"></script>
</head>
<body>
    <div class="head-page-container">
        <div class="head-page-content">
            <h1>Functions</h1>
            <h2>Be an ecological programmer and Re-use!</h2>
        </div>
    </div>
    <div class="content-page-container">
        <div class="content-page-text">
            
            <h3> Key Notes</h3>
            <hr/>
            <ul class="notes">
                <li>Functions are a way to keep portions of code contained. And you can reuse them as many time as you need</li>
                <li>To declare a function you need three things: 
                    <ul>
                        <li>Name of the function</li>
                        <li>(Optional) List of arguments/input data to work with.</li>
                        <li> Code that will perfom the operation on data, all enclosed with "{}" curly braces</li>
                    </ul>
                </li>
                <li>So in code, this how a basic function declaration looks like (function that returns the sum of two parameters):
                    <ul>
                        <li><pre class="example-code">
                            function nameOfFunction(optionalParam1,optionalParam2){
                                //code goes here like ex:
    
                                let result = optionalParam1 + optionalParam2;
                                return result;
                            }
                        </pre></li>
                        <li>You can see this function in action on Demo 1</li>
                    </ul>
                </li>
                <li>A common way to say when you are going to use a function is: "To call a function"</li>
                <li>To call a function you just use the name and the parenthesis, and if the function needs params or argument to work, give it some data, ex:
                    <ul>
                        <li><span class="example-code">nameOfFunction(1,2);</span></li>
                        <li>if function doesnt have any param leave the "()" in blank like <span class="example-code">otherFunction();</span></li>
                    </ul>
                </li>
                <li>In the previous example there's that keyword <span class="example-code">return</span>. This js keywords means that the function will return a value to where the function is called.
                    <ul>
                        <li>In the case of the example of the function <span class="example-code">nameOfFunction(optionalParam1,optionalParam2)</span>, you can see it "returns" the variable <span class="example-code">result</span></li>
                        <li>And before that line of code, you see that <span class="example-code">result</span> is declared and initialized asi <span class="example-code">let result = optionalParam1 + optionalParam2;</span></li>
                        <li>So, for example if you call the function <span class="example-code">nameOfFunction(optionalParam1,optionalParam2)</span> as follows : <span class="example-code">nameOfFunction(1,2);</span>, it will return the value of 3.</li>
                        <li>Again, you can see this in action on Demo 1</li>
                        <li> Note: is not always neccesary to use the <span class="example-code">return</span> keyword in your functions, it's optional and is just needed when you need that your function returns a value of a certain operation.</li>
                    </ul>
                </li>
                <li>Another way to declare a function is through vars. (remember that almost everything in JS is an object), for example let's declare a function that does the exponentiation operation:
                    <ul>
                        <li><span class="example-code">const exponetialOp = function(number,exponential){ return Math.pow(number,exponential); }</span></li>
                        <li>Altough you created the previous function through a variable, in this case, a const, you still call that function as you would do with a normal function as :</li>
                        <li>For example, calling the function to do the 5^2 operation would be like <span class="example-code">exponentialOp(5,2);</span></li>
                        <li>This type of functions (declaring them through a variable) are called function expressions.</li>
                    </ul>
                </li>
                <li>Arrow function is a shorter way of creating function expressions
                    <ul>
                        <li>Example of basic arrow function <span class="example-code">const arrowFunction = (num1,num2) => { num1 + num2 };</span></li>
                        <li>In the previous example, you see the parameters/arguments, followed by an arrow "=>", then the curly braces "{}" and inside there, the code. </li>
                        <li>If the code inside the arrow function is just only one line of code, it will <span class="example-code">return</span> the value automatically. (implicit return)</li>
                        <li>If there's only one argument, you could declare your function expressions without "()" like <span class="example-code">const arrowFunction = num1 => num1 + 2;</span> </li>
                        <li>If there isnt any argument you could either skip the parenthesis or leave it in blank like <span class="example-code">const arrowFunction = => 3*2;</span> or <span class="example-code">const arrowFunction = () => 3*2;</span></li>
                        <li>Remember that if your code block is more than one line of code and you want to <span class="example-code">return</span> a value, you will need the keyword return, implicit return only works when the code block is just one line.
                            <pre class="example-code">
                                const arrowFunction = (num1,num2) => {
                                    let sum = num1 + num2;
                                    return sum;
                                };
                            </pre>
                        </li>
                        <li>Remember that if you want to return an object literal in an arrow function, you will need to put on your code some parenthesis, otherwise it wouldn't work like:
                            <pre class="example-code">
                                const arrowFunction = () => ({firstName:'lol'});
                            </pre>
                        </li>
                    </ul>
                </li>
                <li>Let's talk about <span class="example-code">this</span> keyword
                    <ul>
                        <li>I REPEAT, <span class >this</span> is a keyword!, not a variable nor an object or something you can declare!  </li>
                        <li>So... say... what is <span class="example-code">this</span>? Basically <span class="example-code">this</span> keyword refers or points to an object. Which object you say?  it depends:</li>
                        <li>By itself alone or inside a function, it refers to the "global object", global object changes depending on where your JS code is running. if your JS code is running in a client browser, it will point you to the <i>window</i> object. In strict mode, it will just return you an "undefined". (See demo3)</li>
                        <li>In an object method, <span class="example-code">this</span> refers to the object. (See demo 4) For example, we have the following function, inside that function we have an object called 
                            <span class="example-code">piObj</span>. That object has a property called <span class="example-code">pi</span> and a method called <span class="example-code">getPi</span>. 
                            That method returns the value of the property <span class="example-code"> pi</span>. To refer to that property inside the object we use <span class="example-code">this.pi</span> 
                            <pre class="example-code">
                                const scopeFunction = () => {

                                    let piObj = {
                                        pi:3.14159265359,
                                        getPi: function() { return this.pi; }
                                    };
                                
                                    console.log(piObj.getPi());

                                };
                            </pre>
                        </li>
                        <li>In an event, <span class="example-code">this</span> refers to the element that the event receives (more of this in ...)</li>
                    </ul>
                </li>
                <li>Execution context: Environment that handles and executes  JS code. 
                    <ul>
                        <li>The execution context contains the code that's currently running and everything that aids to its execution</li>
                        <li>There are two kinds of Execution context:
                            <ul>
                                <li>Global Execution Context (GEC) : Whenever the JavaScript engine receives a script file, it first creates this default execution context. It's where all JavaScript code that is not inside of a function gets executed.</li>
                                <li>Function Execution Context (FEC) : When you call to a function.  JS engine creates a special Execution context called Function Execution Context within the Global Execution Context to run the code inside that function.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>When calling a function, depending on where did you call that function will define the execution context of that function. So, this is why <span class="example-code">this</span> varies</li>
                <li>In a way, functions are "objects" to in JS, so basically, functions have methods too, and there are methods to control the context of the object: <span class="example-code">bind()</span>,<span class="example-code">call()</span> and <span class="example-code">apply()</span></li>
                <li>With <span class="example-code">bind()</span> you can set a different starting point for your functions. For example, if you create an object, then if you create a function using the <span class="example-code">this</span> keyword, by default, <span class="example-code">this</span> will point to the global object. But using<span class="example-code">bind()</span> you can set the object as starting point as the following example: (see Demo 5)
                    <pre class="example-code">
                        let myObject = { 
                            firstName:"Steve",
                            lastName:"Irwin"
                        };

                        function myFunction() { console.log("Hi I'm " + this.firstName + " "+ this.lastName ) }
                        myFunction(); <span class="comment">//will print on console: "Hi I'm undefined undefined"</span>
                  
                        let myBindFunction = myFunction.bind(myObject);
                        myBindFunction(); <span class="comment">//will print on console: "Hi I'm Steve Irwin"</span>
                        
                    </pre>
                </li>
                <li>With <span class="example-code">call()</span>, aside from changing the context, you can pass information (See Demo 6)
                    <pre class="example-code">
                        function meetBiologist(message) { console.log('Hey! Meet ' + this.firstName + ' '+ this.lastName + '! This person has the following message for you: ' + message) }

                        const biologist = { 
                            firstName:"Steve",
                            lastName:"Irwin"
                        };
                    
                        meetBiologist.call(biologist,"Take care of my cocodriles!"); <span class="comment">//Will print to console: 'Hey! Meet Steve Irwin! This person has the following message for you: Take care of my cocodriles!'</span>
                    </pre>
                </li>
                <li><span class="example-code">apply()</span> is more of the same than <span class="example-code">call()</span>, but with arrays: (See Demo 7)
                    <pre class="example-code">
                        function meetTheOffice(firstName,secondName,thirdName){
                            console.log(this.message, firstName);
                            console.log(this.message, secondName);
                            console.log(this.message, thirdName);
                        }
                        
                        const greet = { message:'Hello '};
                    
                        meetTheOffice.apply(greet,["Michael Scott", "Pam", "Jim"]);
                    </pre>
                </li>
                <li> Normally when you create a function, the variables and functions inside it  are not accessible to the outer scope of it.  But, using "closures" you can make those vars. and functions inside the function accessible outside of it
                    <ul>
                        <li>The following example shows how to create a function with a variable and a function accessible from outside (closure), see Demo 8 to see this in action: </li>
                        <li> <pre class="example-code"> 
                            const myId = function(){
                                let myData ={
                                    firstName: "",
                                    lastName: "",
                                    yearOfBirth: 0
                                };
                            
                                function setData(firstName, lastName, yearOfBirth){
                                    myData["firstName"] = firstName;
                                    myData["lastName"] = lastName;
                                    myData["yearOfBirth"] = yearOfBirth;
                                }
                            
                                return {
                                    setMyData : function(firstName,lastName,yearOfBirth) { setData(firstName,lastName,yearOfBirth); },
                                    getMyData : function() { return myData; }
                                }
                            };
                            
                            const Jorge_Data = myId();
                            Jorge_Data.setMyData("Jorge", "Luna", 1993);
                        
                            const Dary_Data = myId();
                            Dary_Data.setMyData("Dary", "Esquivel", 1994);
                        
                            console.log(Jorge_Data.getMyData());
                            console.log(Dary_Data.getMyData());
                        </pre></li>
                        <li>Let's review the previous code. As you can see, we create a function expression called myId.</li>
                        <li>Then, we add inside that function a var called <span class="example-code">myId</span> that holds some basic personal data, and a function called <span class="example-code">setData</span> that allows us to modify the data of <span class="example-code">myId</span></li>
                        <li>This variable and function are not accessible from outside the function. So... how do we access to them?</li>
                        <li>This is where fun begins. Remember <span class="example-code">return</span> keyword? you can also return objects with methods/functions. </li> 
                        <li>So, in this case we return an object with two methods, <span class="example-code">setMyData</span> that access to <span class="example-code">setData</span> function, and <span class="example-code">getMyData</span> that returns the value of <span class="example-code">myData</span></li>
                        <li> Then you can use the function as you like. As it returns an object. You can use it in two different instances, and methods will do the same thing, but it will return different stuff as you can see in the example. </li>
                        <li> Basically, you can use functions with closure to create an object template and re use it whenever you like. MAN! IT'S LIKE CLASSES AND OBJECTS IN OOP Programming!!!</li>

                    </ul>

                </li>

            </ul> 

            
            <h3> Demos </h3>
            <hr />
            <p>To see the code and the logs, use Web Dev tools, to achieve this in Chrome, right click and select the "Inspect" option!</p>
            <ul class="demos-list">
                <li id="demo1"> <span class="demo-button" onclick="demo1();">Demo 1</span> - Showing how the basic function in action!.</li>
                <li id="demo2"> <span class="demo-button" onclick="demo2();">Demo 2</span> - Showing how the basic function expression in action!.</li>
                <li id="demo3"> <span class="demo-button" onclick="demo3();">Demo 3</span> - Showing how this works if used as alone.</li>
                <li id="demo4"> <span class="demo-button" onclick="demo4();">Demo 4</span> - Showing how this changes depending on where's called </li>
                <li id="demo5"> <span class="demo-button" onclick="demo5();">Demo 5</span> - Showing how to use bind().</li>
                <li id="demo6"> <span class="demo-button" onclick="demo6();">Demo 6</span> - Showing how to use call().</li>
                <li id="demo7"> <span class="demo-button" onclick="demo7();">Demo 7</span> - Showing how to use apply().</li>
                <li id="demo8"> <span class="demo-button" onclick="demo7();">Demo 7</span> - Showing a closure in action.</li>
            </ul>
        </div>
    </div>
</body>
</html>